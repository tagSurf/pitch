<div id="pitch">
	<div class="message alert alert-success" id="success-message" style="display:none; width:300px;margin-left:auto;margin-right:auto"></div>
  <div class="message alert alert-danger" id="error-message"  style="display:none; width:300px;margin-left:auto;margin-right:auto"></div>

	<div class="drop-target top"></div>
 	<!-- ko if: currentCard() -->
	<div id="card" data-bind="pep: currentCard, css:currentCard().candidate" >
		<div id="content-title"></div>
		<div id="content-wrapper">
			<div id="card-content" data-bind="html: currentCard().excerpt"></div>
		</div>
	</div>
	<!-- /ko -->
	<!-- ko if: !currentCard() -->
	<div class="panel panel-default" style="max-width:300px;margin:auto">
  	<div class="panel-body">
			<p>
				Pitch is all building a community for innovators to easily share their ideas and get transparent, feedback quickly.
			</p>
			<p>
				Help us grow that community by sharing your ideas.
			</p>
			<button class="btn btn-default btn-lg btn-block">Share</button>
		</div>
	</div>
	<!-- /ko -->

	<div class="drop-target left"></div>
	<div class="drop-target left-bottom"></div>

	<div class="drop-target right"></div>
	<div class="drop-target right-bottom"></div>

</div>
<% content_for :script do %>
	<script type="text/javascript">
	var CardModel = function(cardId, excerpt){
		var self = this;
		self.cardId = cardId;
		self.excerpt = excerpt;
		self.candidate = ko.observable("none");
		self.vote = ko.observable("none");

		self.candidate.subscribe(function(value){
			console.log("Candidate is now " + value);
		});
	};

	var VoteViewModel = function(data, nextPage){
		var self = this;
		self.nextPage = nextPage;
		//all cards
		self.cards = ko.observableArray();
		//the card in view
		self.currentCard = ko.observable();

		self.currentCard.subscribe(function(card){
			if(!card){ return; }

			self.currentCard().vote.subscribe(
				function(vote){
	      	if(vote === 'maybe' || vote === 'yes' || vote === 'no'){
	      		var postUrl = '<%= votes_path() %>';
	      		var data = {
	      			'vote' : {
	      				'card_id' : self.currentCard().cardId,
	      				'vote_type' : vote
	      			}
	      		};

	      		var deferred = Application.ajaxPost(postUrl, data);
	      		deferred.done(function(data, textStatus, jqXHR) {
							if(typeof data !== 'undefined' && typeof data.status != 'undefined'){
								var successful = data.status === 'success';

								if(successful && self.cards().length > 0){
									self.currentCard(self.cards.shift());
									self.currentCard.valueHasMutated();
								} else {
									self.currentCard(null);
								}
							}
						});
	    		}
	    	}
		   );
		});

		var mapDataToCards = function(cardsData){
			if( typeof cardsData === 'undefined' || !cardsData){ return; }

			for(var i = cardsData.length - 1; i >= 0; i --){
				var card = cardsData[i];
				if(!self.currentCard() || self.currentCard().cardId != card.id){
					//don't reappend the card we're already viewing
					var model = new CardModel(card.id, card.excerpt);
					//add the to the front of the array so that we keep the order consistent
					self.cards.unshift(model);
				}
			}
		};

		(function(){
			mapDataToCards(data);

			if(self.cards().length > 0){
				self.currentCard(self.cards.shift());
			}
			//try to get more cards every minute
			window.setInterval(function(){
				if(self.nextPage){
					var deferred = $.ajax({
						'type' : 'GET',
						'url' : self.nextPage
					});

					deferred.done(
						function(data, textStatus, jqXHR) {
							if(typeof data !== 'undefined' && typeof data.status != 'undefined' && typeof data.result !== 'undefined'){
								var successful = data.status === 'success';
								if(successful && data.result.cards){
									mapDataToCards(data.result.cards);
								}
							}
						}
					);
				}
			}, 60 * 1000);
		})();
	};

	ko.bindingHandlers.pep = {
    init : function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext){
      var $element = $(element);
      var observable = valueAccessor()().candidate;
      var settle = valueAccessor()().vote;

      var centerElement = function(){
      	var width = $element.outerWidth();
				var height = $element.outerHeight();

				var parentWidth = $element.parent().width();
				var parentHeight = $element.parent().height();

				var top = (parentHeight - height)/2;
				var left = (parentWidth - width)/2;

				$element.css("left", left + "px");
				$element.css("top", top + "px")
      };

      $element.pep(
	      {
					droppable: '.drop-target',
					//smooths out animation
	 	 			useCSSTranslation: false,
					overlapFunction: function($a, $b){

						var cardRect = $b[0].getBoundingClientRect();
	    			var regionRect = $a[0].getBoundingClientRect();

	    			var overlaps = false;

	    			if($a.hasClass("top")){
	    				overlaps = cardRect.top < regionRect.bottom;
	    				if(overlaps){
	    					observable("maybe");
	    				}
	    			} else if ($a.hasClass("left")){
							overlaps = cardRect.left < regionRect.right;
							if(overlaps){
								observable("no");
							}
	    			} else if ($a.hasClass("left-bottom")){
	    				//the card is going down, and the distance between the region's right edge
	    				//and its left edge is more than 50% of the card's width
	    				overlaps = cardRect.bottom > regionRect.bottom && (cardRect.left < regionRect.right) &&
	    					(cardRect.right - regionRect.right) < (cardRect.width/ 2);

	    				if(overlaps){
	    					observable("no");
	    				}
	    			} else if ($a.hasClass("right-bottom") ){
	    				//the card is going down, and the distance between the region's left edge
	    				//and its right edge is more than 50% of the card's width

	    				overlaps = cardRect.bottom > regionRect.bottom &&
	    					(cardRect.right > regionRect.left) &&
	    					cardRect.right - regionRect.left > (cardRect.width/ 2);

	    				if(overlaps){
	    					observable("yes");
	    				}
	    			} else if ($a.hasClass("right")){

	    				overlaps = cardRect.right > regionRect.left;
	    				if(overlaps){
	    					observable("yes");
	    				}
	    			}
	    			return overlaps;
					},
					start : function(ev, obj) {
						//the card has started moving
					},
					drag : function(ev, obj){
						if(obj.activeDropRegions.length == 0) {
							observable("none");
						}
					},
					stop : function(ev, obj) {
						//the card has stopped moving,
						//if its not moving back to the
						if (obj.activeDropRegions.length == 0) {
							//center the card
							centerElement();
							observable("none");
						}
					},
					rest: function(ev, obj){
						if(obj.activeDropRegions.length > 0){
							settle(observable());
						}
					}
				}
			);

			//resize the parent
			var resizeParent = function(){
				var $parent = $element.parent();
				$parent.height(window.innerHeight - $parent.position().top);
			}

			resizeParent();
			//center element
			centerElement();

			$(window).resize(function(){
				resizeParent();
			});
		}
	};

	$(document).ready(function(){
		var data = <%=raw @all_cards.as_json.to_json %>;
		var nextPage =  '<%= cards_path(:format => "json")%>';
		var viewModel = new VoteViewModel(data, nextPage);
		ko.applyBindings(viewModel);
	});
	</script>
<% end %>